구글 클라우드 콘솔에서 OAuth2를 사용하기 위한 사용자 인증 정보를 만들려고 보면 'OAuth 2.0 클라이언트 ID'와 '서비스 계정'이 있습니다.

이전에 블로깅했던, 구글 플레이 스토어 영수증 검증 및 처리 API를 개발하기 위해 구글 클라우드 콘솔을 만지던 중에 이 2가지의 차이점에 대해서 좀 더 깊이 알게되서 정리해보려고 합니다.

결론부터 말하면, 'OAuth 2.0 클라이언트 ID'를 사용할 때는 Redirect URL을 등록해주어야 하지만 '서비스 계정'을 사용할 때는 Redirect URL이 필요없습니다.


## OAuth 2.0과 서비스 계정 인증의 기본 개념 🙄
### OAuth 2.0 클라이언트 ID

OAuth 2.0은 사용자 데이터에 대한 제한된 접근을 제3자 애플리케이션에 제공하기 위한 인증 프로토콜입니다. 주요 특징은 다음과 같습니다:

1. 사용자 중심: 최종 사용자가 자신의 데이터에 대한 접근 권한을 부여합니다.
2. 권한 위임: 사용자 비밀번호를 공유하지 않고도 특정 리소스에 대한 접근을 허용합니다.
3. 토큰 기반: 접근 토큰을 사용하여 인증과 권한 부여를 관리합니다.
4. 리다이렉트 필요: 사용자 동의를 얻기 위해 리다이렉트 URL이 필요합니다.

### 서비스 계정

서비스 계정은 사용자가 아닌 애플리케이션이나 가상 시스템을 위한 특별한 유형의 계정입니다. 주요 특징은 다음과 같습니다:

1. 애플리케이션 중심: 특정 서비스나 애플리케이션을 대신하여 작동합니다.
2. 키 기반 인증: JSON 키 파일을 사용하여 인증합니다.
3. 직접 접근: 사용자 개입 없이 리소스에 직접 접근합니다.
4. 리다이렉트 불필요: 사용자 동의 과정이 없어 리다이렉트 URL이 필요 없습니다.

이 두 방식의 주요 차이점은 **사용자 개입 여부와 인증 흐름**에 있습니다. OAuth 2.0은 사용자의 동의를 필요로 하지만, 서비스 계정은 백그라운드에서 자동으로 작동합니다.


## OAuth 2.0 클라이언트 인증 🙄
### 작동 원리 (구글 예시)

1. 사용자가 애플리케이션(클라이언트)에서 구글 계정으로 로그인하려고 합니다.
2. 애플리케이션은 사용자를 구글 인증 서버(서버A)의 OAuth 2.0 인증 페이지로 리다이렉트합니다.
3. 사용자는 구글 인증 서버(서버A)에서 자신의 구글 계정으로 로그인합니다.
4. 로그인 후, 같은 페이지에서 애플리케이션이 요청하는 권한에 대한 동의를 묻습니다.
5. 사용자가 권한을 승인하면, 구글 인증 서버(서버A)는 사용자를 미리 지정된 리다이렉트 URL로 돌려보냅니다. 이때 인증 코드가 함께 전달됩니다.
6. 애플리케이션은 이 인증 코드를 사용하여 구글 인증 서버(서버A)에 액세스 토큰을 요청합니다.
7. 구글 인증 서버(서버A)가 액세스 토큰을 발급하면, 애플리케이션은 이 토큰을 사용하여 구글 리소스 서버(서버B)에서 사용자 데이터에 접근할 수 있습니다.

여기서 구글 인증 서버(서버A)는 인증과 권한 부여를 담당하고, 구글 리소스 서버(서버B)는 실제 사용자 데이터(예: 프로필 정보, 이메일 등)를 저장하고 제공합니다.


### 리다이렉트 URL

이 과정에서 리다이렉트 URL이 필요한 이유는 보안 때문입니다.

구글 인증 서버는 등록된 리다이렉트 URL로만 인증 코드를 전송하는데, 이 리다이렉트 URL을 등록하는 과정이 없다면 악의적인 제 3자가 인증 코드를 받아갈 수도 있습니다.

그리고 리다이렉트 URL이 없다면 위에 5번 단계에서 사용자가 인증을 완료한 후에 애플리케이션으로 돌아갈 수 있는 방법이 없기 때문에 인증 과정을 완료할 수 없습니다.

## 서비스 계정 인증 🙄
### 작동 원리

1. 애플리케이션 서버는 구글 클라우드 콘솔에서 발급받은 JSON 키 파일을 사용하여 스코프를 합쳐서 JWT 토큰을 생성합니다.
2. 애플리케이션 서버는 생성된 JWT 토큰을 구글 인증 서버에 보냅니다.
3. 구글 인증 서버는 JWT 토큰을 검증하고, 유효하다면 액세스 토큰을 발급합니다.
4. 애플리케이션 서버는 액세스 토큰을 사용하여 구글 리소스 서버에 요청을 보내서 사용자 데이터에 접근합니다.

### JSON 키 파일의 역할

JSON 키 파일은 서비스 계정의 인증 정보를 포함하고 있습니다. 이 파일은 구글 클라우드 콘솔에서 발급받은 후, 애플리케이션 서버에 저장됩니다.

이 키 파일과 원하는 스코프 정보를 합쳐서 JWT 토큰을 생성하고, 이를 구글 인증 서버에 보냅니다.

### 리다이렉트 URL 필요 없는 이유

서비스 계정은 인증 서버에 보낼 토큰을 내부에서 직접 만들고 인증 서버에서 검증만 받으면 바로 액세스 토큰을 발급 받기 때문에 리다이렉트 URL이 필요 없습니다.

## 두 방식의 차이 🙄

1. 사용자 개입 여부: OAuth 2.0은 사용자 개입이 필요하지만, 서비스 계정은 사용자 개입이 필요하지 않습니다.

2. 인증 흐름: OAuth 2.0은 사용자 동의를 얻기 위해 리다이렉트 URL이 필요하지만, 서비스 계정은 리다이렉트 URL이 필요하지 않습니다.

3. 보안: OAuth 2.0은 리다이렉트 URL을 통해 보안을 유지하지만, 서비스 계정은 키 파일을 사용하여 보안을 유지합니다.

4. 사용 목적: OAuth 2.0은 사용자 데이터에 대한 제한된 접근을 제공하는 것이 목적이지만, 서비스 계정은 애플리케이션이나 서비스를 대신하여 작동하는 것이 목적입니다.

### 구현 복잡성 비교

OAuth 2.0 클라이언트 인증은 복잡한 인증 흐름을 가지고 있습니다. 사용자 동의를 얻기 위해 리다이렉트 URL을 등록하고, 인증 코드를 받아 액세스 토큰을 발급받는 과정이 필요합니다.

서비스 계정 인증은 키 파일을 사용하여 인증하는 방식이므로 구현이 비교적 간단합니다. 

### 리다이렉트 URL 유무 차이

서비스 계정을 사용한 인증은 애플리케이션 서버에서 JSON 키파일을 통해 직접 토큰을 만들고 서버에 보내서 토큰을 검증 받은 후 바로 액세스 토큰을 받아옵니다. **(단일 HTTP 요청-응답으로 인증 완료)**

하지만 OAuth 2.0 클라이언트 인증에서는 사용자가 브라우저를 통해 로그인을 하고, 권한을 승인하고, 인증 코드를 받아 애플리케이션으로 돌아오고 (이 떄 리다이렉트 URL 필요) 애플리케이션에서 인증 코드를 구글 인증 서버에 보내서 액세스 토큰을 받아옵니다. **(여러 단계의 리다이렉션 필요)**

### 각 방식의 장단점
#### 서비스 계정 인증
- 장점
    - 사용자 개입 없이 자동화된 인증 가능
    - 서버 간 통신에 적합
    - 구현이 상대적으로 간단
- 단점
    - 보안에 민감한 JSON 키 파일 관리 필요
    - 특정 사용자 컨텍스트에서의 작업에는 부적합

#### OAuth 2.0 클라이언트 인증
- 장점
    - 사용자 동의 기반의 안전한 인증 프로세스
    - 사용자 컨텍스트에서의 작업에 적합
    - 토큰 갱신 및 권한 관리가 용이
- 단점
    - 복잡한 인증 흐름과 구현 난이도
    - 사용자 개입이 필요하여 자동화에 제한

### 적절한 사용 상황

- 서비스 계정 인증:
    - 서버 간 통신이 필요할 때
    - 백그라운드 작업이나 배치 프로세스를 실행할 때

- OAuth 2.0 클라이언트 인증:
    - 사용자 데이터에 접근해야 하는 웹 애플리케이션이나 모바일 앱에서
    - 사용자별로 다른 권한이 필요한 경우
    - 제3자 애플리케이션에 제한된 접근 권한을 부여해야 할 때

    












