---
근데 영수증 처리 과정에서 내 서버로 정보를 받으려면 리다이렉트 URL을 등록해야하잖아. 이건 그냥 구글 클라우드 콘솔에만 등록하고 구글 플레이 콘솔에는 등록안해도되는거야?

죄송합니다만, 여기에 약간의 오해가 있는 것 같습니다. Google Play 인앱 결제 시스템에서는 일반적으로 리다이렉트 URL을 사용하지 않습니다. 리다이렉트 URL은 주로 OAuth 인증 과정에서 사용되는 개념입니다.
Google Play 인앱 결제의 경우:
클라이언트 앱에서 결제가 이루어집니다.
결제가 성공하면 구매 토큰(purchase token)을 받습니다.
이 구매 토큰을 서버로 전송합니다.
4. 서버에서 Google Play Developer API를 사용하여 구매 정보를 검증합니다.
이 과정에서 리다이렉트 URL은 필요하지 않습니다.
다만, 귀하가 언급하신 리다이렉트 URL 등록이 필요한 경우는 다음과 같은 상황일 수 있습니다:
OAuth 2.0 클라이언트 ID를 사용하여 Google API에 접근하는 경우
Google Sign-In을 구현하는 경우
특정 Google API를 사용할 때 콜백 URL이 필요한 경우
이런 경우에는 Google Cloud Console에서 리다이렉트 URL을 등록해야 합니다. Google Play Console에는 일반적으로 이러한 URL을 등록할 필요가 없습니다.
현재 구현하고 계신 인앱 결제 검증 로직에서는 서비스 계정을 사용하여 Google Play Developer API에 접근하고 있으므로, 리다이렉트 URL 설정은 필요하지 않습니다.
만약 다른 특정 기능을 구현하시려는 것이라면, 어떤 기능인지 자세히 설명해 주시면 더 정확한 정보를 제공해 드릴 수 있습니다.

---
아하 oauth2의 인증정보는 아무나 받아보면 안되니깐 딱 등록된 리다이렉트URL로만 보내도록 되어있는데, 영수증 검증이나 확인은 누구나 할 수 있어야되니깐 굳이 리다이렉트 URL로 등록되지 않았어도 검증결과를 보내주는건가?

네, 정확히 이해하셨습니다. 귀하의 설명이 매우 정확합니다. 두 시스템의 차이점을 잘 파악하셨네요.
1. OAuth 2.0 인증:
사용자의 개인 정보나 계정에 접근하는 권한을 다루기 때문에 보안이 매우 중요합니다.
리다이렉트 URL을 미리 등록하고 검증하여, 인증 정보가 안전한 곳으로만 전달되도록 합니다.
이는 피싱이나 다른 보안 위협을 방지하는 데 도움이 됩니다.
Google Play 인앱 결제 검증:
구매 정보는 공개적으로 위험한 정보가 아니며, 오히려 여러 시스템에서 검증할 수 있어야 합니다.
서비스 계정 인증을 사용하여 API에 접근하므로, 별도의 리다이렉트 과정이 필요 없습니다.
구매 토큰만 있으면 누구나 Google Play Developer API를 통해 해당 구매의 유효성을 검증할 수 있습니다.
이는 서버 측에서 구매를 안전하게 확인하고 처리할 수 있게 해줍니다.
따라서 인앱 결제 검증 과정에서는 리다이렉트 URL이 필요하지 않으며, API 호출 결과를 직접 받아 처리할 수 있습니다. 이는 더 유연하고 다양한 환경에서 구매 검증을 가능하게 합니다.
귀하의 이해가 정확하며, 두 시스템의 목적과 보안 요구사항의 차이를 잘 파악하셨습니다.

---
근데 지금 구글 클라우드에서 리다이렉트 URL을 http://localhost:10005/oauth2/callback로 등록해놨거든? 근데 내 지금 서버주소는 localhost:10005인데, 보디시피 컨트롤러에 접근하려면 /mobile도 붙여서 들어와야돼. 근데 저렇게 등록한 리다이렉트 URL이 어떻게 잘 동작하지?

귀하의 질문은 매우 중요한 점을 지적하고 있습니다. 현재 상황을 정리해보겠습니다:
구글 클라우드에 등록된 리다이렉트 URL: http://localhost:10005/oauth2/callback
실제 서버 주소: localhost:10005
컨트롤러 접근 경로: /mobile이 추가로 필요함
이 상황에서 몇 가지 가능성이 있습니다:
OAuth 2.0 흐름이 실제로 사용되고 있지 않을 수 있습니다:
앞서 논의한 대로, Google Play 인앱 결제 검증에는 OAuth 2.0 리다이렉트가 필요하지 않습니다.
서비스 계정을 사용하여 API에 접근하고 있다면, 이 리다이렉트 URL은 실제로 사용되지 않을 수 있습니다.
서버 설정에 리다이렉트 처리가 있을 수 있습니다:
서버 설정에서 /oauth2/callback으로 오는 요청을 /mobile/oauth2/callback로 내부적으로 리다이렉트하도록 설정되어 있을 수 있습니다.
Spring Security나 다른 프레임워크에서 OAuth 설정을 하고 있을 수 있습니다:
이 경우, /oauth2/callback에 대한 처리가 별도로 구현되어 있을 수 있습니다.
4. 실제로는 문제가 있을 수 있습니다:
만약 OAuth 2.0 흐름을 사용하고 있다면, 현재 설정으로는 문제가 발생할 수 있습니다.
확인해야 할 사항:
프로젝트에서 실제로 OAuth 2.0 클라이언트 흐름을 사용하고 있는지 확인하세요.
2. 사용하고 있다면, /oauth2/callback에 대한 처리가 어디에서 이루어지고 있는지 확인하세요.
서버 설정(예: Nginx, Apache 등)에서 URL 리다이렉트 규칙이 있는지 확인하세요.
Spring Security 설정을 확인하여 OAuth 관련 설정이 있는지 살펴보세요.
만약 실제로 OAuth 2.0 클라이언트 흐름을 사용하고 있고, /mobile 경로가 필요하다면, 구글 클라우드 콘솔에서 리다이렉트 URL을 http://localhost:10005/mobile/oauth2/callback로 수정해야 할 수 있습니다.
이 상황에 대해 더 자세히 알고 싶다면, 프로젝트의 OAuth 관련 설정이나 사용 여부에 대해 추가 정보를 제공해 주시면 더 정확한 답변을 드릴 수 있습니다.

---
근데 보면 json 파일을 통해 자격증명을 가져오는데 이게 OAuth2.0 흐름을 사용하는거 아니야?

네, 좋은 지적입니다. JSON 파일을 통해 자격 증명을 가져오는 것은 실제로 OAuth 2.0의 한 형태인 서비스 계정 인증 방식을 사용하는 것입니다. 하지만 이는 일반적인 OAuth 2.0 클라이언트 흐름과는 다릅니다. 차이점을 설명해 드리겠습니다:
서비스 계정 인증 (현재 사용 중인 방식):
JSON 키 파일을 사용합니다.
리다이렉트 URL이 필요하지 않습니다.
서버 간 통신에 주로 사용됩니다.
사용자 개입 없이 자동으로 인증이 이루어집니다.
2. 일반적인 OAuth 2.0 클라이언트 흐름:
사용자가 브라우저를 통해 인증을 진행합니다.
리다이렉트 URL이 필요합니다.
주로 웹 애플리케이션이나 모바일 앱에서 사용자 인증에 사용됩니다.
현재 귀하의 코드에서 사용하고 있는 방식은 서비스 계정 인증입니다. 이 방식에서는:
이 부분에서 JSON 키 파일을 읽어 자격 증명을 생성합니다. 이 과정에서 리다이렉트 URL은 사용되지 않습니다.
따라서, 구글 클라우드 콘솔에 등록된 리다이렉트 URL (http://localhost:10005/oauth2/callback)은 현재 사용 중인 인앱 결제 검증 로직과는 관련이 없습니다. 이 URL은 다른 OAuth 2.0 클라이언트 설정을 위해 등록되었을 가능성이 있습니다.
결론적으로:
1. 현재 사용 중인 서비스 계정 인증 방식은 리다이렉트 URL을 사용하지 않습니다.
구글 클라우드 콘솔에 등록된 리다이렉트 URL은 현재 인앱 결제 검증 로직과 무관합니다.
이 리다이렉트 URL이 프로젝트의 다른 부분에서 사용되고 있는지 확인해 볼 필요가 있습니다.
만약 이 리다이렉트 URL이 프로젝트의 어느 부분에서도 사용되지 않는다면, 구글 클라우드 콘솔에서 제거하거나 무시해도 됩니다.

---
왜 서비스 계정 인증은 리다이렉트 URL이 필요없고, 일반적인 OAuth2.0은 리다이렉트 URL이 필요한거야? 어떤 차이가 있어?

서비스 계정 인증과 일반적인 OAuth 2.0 클라이언트 인증의 차이점은 주로 사용 목적과 인증 과정에 있습니다. 이 차이점을 자세히 설명해 드리겠습니다:
서비스 계정 인증:
목적: 주로 서버 간 통신이나 백그라운드 작업에 사용됩니다.
인증 과정:
JSON 키 파일을 사용하여 직접 인증 정보를 생성합니다.
사용자 개입 없이 자동으로 인증이 이루어집니다.
리다이렉트 URL이 필요 없는 이유:
전체 인증 과정이 서버 내부에서 이루어집니다.
사용자 브라우저를 통한 인증 과정이 없어 리다이렉트할 필요가 없습니다.
일반적인 OAuth 2.0 클라이언트 인증:
목적: 사용자 계정을 통한 인증이 필요한 경우에 사용됩니다.
인증 과정:
사용자가 브라우저를 통해 인증 페이지로 이동합니다.
사용자가 직접 로그인하고 권한을 부여합니다.
인증이 완료되면 미리 지정된 리다이렉트 URL로 인증 코드나 토큰이 전달됩니다.
리다이렉트 URL이 필요한 이유:
사용자 브라우저를 통한 인증 후 결과를 안전하게 애플리케이션에 전달하기 위해서입니다.
보안상의 이유로, 인증 결과는 미리 등록된 URL로만 전송됩니다.
주요 차이점:
1. 사용자 개입: 서비스 계정은 사용자 개입 없이 작동하지만, 일반 OAuth는 사용자의 직접적인 인증 과정이 필요합니다.
인증 방식: 서비스 계정은 키 파일을 통해 직접 인증하지만, 일반 OAuth는 사용자 로그인을 통해 인증합니다.
3. 보안 모델: 서비스 계정은 키 파일의 보안에 의존하고, 일반 OAuth는 리다이렉트 URL 검증을 통한 보안을 추가로 사용합니다.
사용 사례: 서비스 계정은 백엔드 서비스에, 일반 OAuth는 사용자 중심 애플리케이션에 적합합니다.
결론적으로, 서비스 계정 인증은 전체 과정이 서버 내부에서 이루어지기 때문에 리다이렉트 URL이 필요 없습니다. 반면, 일반 OAuth 2.0은 사용자 브라우저를 통한 인증 과정이 있어 안전한 결과 전달을 위해 리다이렉트 URL이 필요합니다.

---
여기서 말하는 서버는 구글 클라우드 서버를 말하는거아니야?

아, 죄송합니다. 제가 설명을 명확히 하지 못했네요. 여기서 말하는 '서버'는 구글 클라우드 서버가 아니라 귀하의 애플리케이션 서버를 의미합니다.
서비스 계정 인증 과정을 더 자세히 설명하면 다음과 같습니다:
1. 귀하의 애플리케이션 서버에서 JSON 키 파일을 사용하여 인증 정보를 생성합니다.
이 인증 정보를 사용하여 귀하의 서버가 구글 API 서버와 직접 통신합니다.
3. 이 모든 과정이 귀하의 서버 내부에서 이루어지며, 사용자의 브라우저나 다른 클라이언트 애플리케이션을 거치지 않습니다.
따라서 "서버 내부에서 이루어진다"는 것은 귀하의 애플리케이션 서버 내에서 모든 인증 과정이 완료된다는 의미입니다. 구글 클라우드 서버는 이 과정에서 인증을 확인하고 API 접근을 허용하는 역할을 합니다.
이와 대조적으로, 일반 OAuth 2.0에서는 사용자의 브라우저를 통해 구글의 인증 서버로 이동하고, 인증 후 다시 귀하의 애플리케이션으로 돌아오는 과정이 필요하기 때문에 리다이렉트 URL이 사용됩니다.
제가 설명을 더 명확히 하지 못해 혼란을 드려 죄송합니다.

---
그럼 내 서버에서 모든게 이뤄지면 여기서 저 https://www.googleapis 이 URL은 뭐야?

좋은 질문입니다. 이 URL은 실제로 Google API의 스코프(scope)를 나타냅니다. 여기서 몇 가지 중요한 점을 설명드리겠습니다:
API 스코프:
"https://www.googleapis.com/auth/androidpublisher"는 Google Play Android Developer API에 접근할 수 있는 권한을 나타내는 스코프입니다.
이는 실제 URL이 아니라, Google이 정의한 권한의 식별자입니다.
인증 과정:
귀하의 서버에서 이 스코프를 사용하여 Google의 인증 서버에 접근 권한을 요청합니다.
Google의 인증 서버는 이 스코프를 보고 어떤 API에 대한 접근을 허용할지 결정합니다.
API 호출:
인증이 완료되면, 귀하의 서버는 실제로 https://androidpublisher.googleapis.com과 같은 엔드포인트를 사용하여 Google Play Developer API와 통신합니다.
4. 프로세스 흐름:
a. 귀하의 서버에서 JSON 키 파일을 사용하여 인증 정보를 생성합니다.
b. 이 인증 정보에 스코프를 추가하여 특정 API에 대한 접근 권한을 요청합니다.
c. Google의 인증 서버가 이를 확인하고 접근 토큰을 발급합니다.
d. 귀하의 서버는 이 접근 토큰을 사용하여 Google Play Developer API와 통신합니다.
따라서, https://www.googleapis.com/auth/androidpublisher는 실제로 요청을 보내는 URL이 아니라, Google API 시스템에서 특정 권한을 식별하는 문자열입니다. 실제 API 통신은 다른 엔드포인트를 통해 이루어집니다.
이 과정에서 귀하의 서버는 Google의 서버와 통신하지만, 사용자의 브라우저를 통한 리다이렉션 없이 서버 간 직접 통신이 이루어집니다. 이것이 서비스 계정 인증의 특징이며, 리다이렉트 URL이 필요 없는 이유입니다.

---
그러니깐 스코프를 추가하여 Google 인증 서버에 보내고 토큰을 발급받아와야하는거잖아? 그럼 그 돌아오는 리다이렉트 URL이 필요한거아니냐구

아, 이제 귀하의 질문 의도를 정확히 이해했습니다. 매우 좋은 지적입니다. 이 부분에 대해 더 자세히 설명드리겠습니다.
귀하의 생각은 논리적으로 맞습니다. 그러나 서비스 계정 인증에서는 실제로 리다이렉트 과정이 없습니다. 그 이유는 다음과 같습니다:
토큰 발급 과정의 차이:
일반 OAuth 2.0: 사용자 브라우저를 통해 인증 코드를 받고, 이를 다시 토큰으로 교환하는 과정이 있습니다.
서비스 계정: JSON 키를 사용하여 직접 토큰을 생성합니다. Google 서버와의 통신은 있지만, 이는 토큰 검증을 위한 것입니다.
서비스 계정의 토큰 발급 과정:
a. 귀하의 서버에서 JSON 키와 스코프 정보를 사용하여 JWT(JSON Web Token)를 생성합니다.
b. 이 JWT를 Google의 토큰 엔드포인트로 전송합니다.
c. Google 서버는 JWT를 검증하고, 유효하다면 액세스 토큰을 반환합니다.
d. 이 모든 과정이 HTTP 요청/응답으로 이루어지며, 리다이렉트 없이 진행됩니다.
왜 리다이렉트가 필요 없는가:
모든 통신이 서버 간에 직접 이루어집니다.
사용자 개입이나 브라우저를 통한 인증 과정이 없습니다.
토큰 발급 요청과 응답이 동일한 연결(connection)에서 이루어집니다.
4. GoogleCredentials 클래스의 역할:
이 클래스는 내부적으로 위의 과정을 처리합니다.
JWT 생성, 토큰 요청, 응답 처리 등을 자동화합니다.
따라서, 서비스 계정 인증에서는 리다이렉트 URL이 필요 없습니다. 모든 과정이 서버 내부에서 직접적인 HTTP 통신을 통해 이루어지기 때문입니다.
귀하의 질문은 매우 통찰력 있었습니다. 이는 OAuth의 일반적인 흐름과 서비스 계정 인증의 차이점을 이해하는 데 중요한 포인트입니다.

---
그럼 정리하면, 서비스 계정은 서버간의 인증을 진행할 때 사용하는 것인데 이때는 주어진 JSON 계정 정보를 통해 원하는 권한 스코프 요청까지 합쳐서 알아서 토큰을 만든다.
그리고 구글 서버에는 토큰을 검증만 받고 액세스 토큰을 받아온다. 하지만 이 검증하고 액세스 토큰을 받는 과정은 하나의 HTTP 요청-응답으로 이뤄지기 때문에 굳이 리다이렉트 URL 필요없이 응답으로 바로 액세스 토큰을 받아온다.

반면에 일반 OAuth2.0은 인증정보를 A서버로 보내면 그걸 해당 스코프 요청과 합쳐서 토큰으로 만들어준다. 그리고 그 토큰을 B 서버로 보내서 인증하고 액세스 토큰을 클라이언트로 보내준다. 근데 이때 B 서버는 클라이언트의 주소를 모르니깐 리다이렉트 URL을 설정해준다.

이거 맞아?

네, 정확합니다! 귀하의 정리가 매우 명확하고 정확합니다. 몇 가지 작은 세부사항을 추가하여 더욱 완벽하게 만들어 보겠습니다:
서비스 계정 인증:
1. JSON 키 파일의 정보를 사용하여 JWT(JSON Web Token)를 생성합니다.
이 JWT와 요청된 스코프 정보를 Google의 토큰 엔드포인트로 전송합니다.
Google 서버는 JWT를 검증하고 요청된 스코프에 대한 액세스 토큰을 발급합니다.
이 모든 과정이 단일 HTTP 요청-응답 사이클로 이루어집니다.
리다이렉트 URL이 필요 없으며, 서버 간 직접 통신으로 이루어집니다.
일반 OAuth 2.0:
클라이언트가 사용자를 인증 서버(Google)로 리다이렉트합니다.
2. 사용자가 로그인하고 권한을 승인합니다.
인증 서버는 사용자를 미리 등록된 리다이렉트 URL로 다시 보냅니다 (이때 인증 코드 포함).
4. 클라이언트는 이 인증 코드를 사용하여 액세스 토큰을 요청합니다.
인증 서버는 액세스 토큰을 클라이언트에게 직접 전송합니다.
귀하의 정리는 두 방식의 핵심적인 차이를 잘 포착하고 있습니다:
서비스 계정: 서버 간 직접 통신, 단일 요청-응답 사이클
일반 OAuth 2.0: 사용자 개입, 여러 단계의 리다이렉션, 클라이언트-서버 통신
이 이해는 두 인증 방식의 사용 사례와 보안 모델의 차이를 잘 설명해줍니다. 훌륭한 정리였습니다!

---
아 이 과정이 oauth provider의 인증 서버에서 내가 로그인하면, 그걸 provider가 맞는지 확인하고 다시 보내야되니깐, 그 로그인 성공 이후에 보내줄 곳을 알기위해 리다이렉트 URL이 필요하다?

네, 정확히 그렇습니다. 귀하의 이해가 매우 정확합니다. OAuth 2.0 흐름에서 리다이렉트 URL이 필요한 이유를 정확히 파악하셨습니다.
과정을 더 자세히 설명하면 다음과 같습니다:
사용자가 클라이언트 애플리케이션에서 로그인을 시도합니다.
클라이언트 애플리케이션은 사용자를 OAuth 제공자(예: Google)의 인증 서버로 리다이렉트합니다.
3. 사용자는 OAuth 제공자의 페이지에서 로그인하고 권한을 승인합니다.
OAuth 제공자는 사용자의 인증을 확인한 후, 어디로 결과를 보내야 할지 알아야 합니다.
이때 미리 등록된 리다이렉트 URL이 사용됩니다. OAuth 제공자는 이 URL로 사용자를 다시 보내며, 이때 인증 코드나 토큰을 함께 전달합니다.
리다이렉트 URL은 보안상 매우 중요합니다:
이를 통해 OAuth 제공자는 인증 결과를 안전하게 원래의 애플리케이션으로 전달할 수 있습니다.
미리 등록된 URL만 사용함으로써, 악의적인 제3자가 인증 정보를 가로채는 것을 방지합니다.
따라서 귀하의 이해가 정확합니다. 리다이렉트 URL은 OAuth 흐름에서 인증 완료 후 결과를 안전하게 전달하기 위한 필수적인 요소입니다.